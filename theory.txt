git bash
$ cd /c/Users/Ефимов/python-django-orm-blog
make setup

$ make setup
rm: cannot remove 'db.sqlite3': No such file or directory
Using CPython 3.13.3
Creating virtual environment at: .venv
Resolved 28 packages in 81ms
Prepared 21 packages in 34.84s
Installed 25 packages in 8.33s
 + asgiref==3.8.1
 + asttokens==3.0.0
 + colorama==0.4.6
 + decorator==5.1.1
 + django==5.1.4
 + django-extensions==3.2.3
 + executing==2.1.0
 + iniconfig==2.0.0
 + ipython==8.31.0
 + jedi==0.19.2
 + matplotlib-inline==0.1.7
 + packaging==24.2
 + parso==0.8.4
 + pluggy==1.5.0
 + prompt-toolkit==3.0.48
 + pure-eval==0.2.3
 + pygments==2.19.1
 + pytest==8.3.4
 + pytest-django==4.9.0
 + ruff==0.9.1
 + sqlparse==0.5.3
 + stack-data==0.6.3
 + traitlets==5.14.3
 + tzdata==2024.2
 + wcwidth==0.2.13
Operations to perform:
  Apply all migrations: blog
Running migrations:
  Applying blog.0001_initial... OK


make test

$ make test
uv run pytest
============================= test session starts =============================
platform win32 -- Python 3.13.3, pytest-8.3.4, pluggy-1.5.0
django: version: 5.1.4, settings: python_django_orm_blog.settings (from ini)
rootdir: C:\Users\Ефимов\python-django-orm-blog
configfile: pyproject.toml
plugins: django-4.9.0
collected 1 item

python_django_orm_blog\blog\tests.py .                                   [100%]

============================== 1 passed in 0.68s ==============================

Ефимов@DESKTOP-06VQ37M MINGW64 ~/python-django-orm-blog (main)
$


make shell

$ make shell
# Shell Plus Model Imports
from python_django_orm_blog.blog.models import Post, PostComment, PostLike, Tag, User
# Shell Plus Django Imports
from django.core.cache import cache
from django.conf import settings
from django.contrib.auth import get_user_model
from django.db import transaction
from django.db.models import Avg, Case, Count, F, Max, Min, Prefetch, Q, Sum, When
from django.utils import timezone
from django.urls import reverse
from django.db.models import Exists, OuterRef, Subquery
Python 3.13.3 (main, Apr  9 2025, 04:04:49) [MSC v.1943 64 bit (AMD64)]
Type 'copyright', 'credits' or 'license' for more information
IPython 8.31.0 -- An enhanced Interactive Python. Type '?' for help.

In [1]:

post = Post.objects.create(title="Первый пост", body="Тест поста", creator=user)

post = Post.objects.first()
author = post.creator
print(author)

user = User.objects.first()
posts = user.post_set.all()

post.creator = another_user
post.save()

user.delete()

on_delete
CASCADE - удаляются все связанные записи
PROTECT - не даст удалить, если есть посты
SET_NULL - устанавливает NULL во внешнем ключе (только для полей, допускающих null=True)
SET_DEFAULT - устанавливает значение по умолчанию
DO_NOTHING - ничего не делает

select_related для связей один к одному и один ко многим. Делает SQL JOIN
prefetch_related для связей один ко многим


In [26]: user = User.objects.create(email="user@example.com", first_name="Ivan", last_name="Petrov", nickname="ivan_petrov")   
INSERT INTO "blog_user" ("created_at", "updated_at", "nickname", "email", "first_name", "last_name")
VALUES ('2025-09-12 13:31:03.552509', '2025-09-12 13:31:03.552632', 'ivan_petrov', 'user@example.com', 'Ivan', 'Petrov') RETURNING "blog_user"."id"

Execution time: 0.011151s [Database: default]

In [27]: post = Post.objects.create(title="Первый пост", body="Тест поста", creator=user)
INSERT INTO "blog_post" ("created_at", "updated_at", "title", "body", "creator_id")
VALUES ('2025-09-12 13:31:18.587149', '2025-09-12 13:31:18.587268', 'Первый пост', 'Тест поста', 5) RETURNING "blog_post"."id" 

Execution time: 0.010314s [Database: default]

In [28]: posts = Post.objects.select_related("creator").all()

In [29]: for post in posts:
    ...:     print(post.creator.nickname)
    ...: 
SELECT "blog_post"."id",
       "blog_post"."created_at",
       "blog_post"."updated_at",
       "blog_post"."title",
       "blog_post"."body",
       "blog_post"."creator_id",
       "blog_user"."id",
       "blog_user"."created_at",
       "blog_user"."updated_at",
       "blog_user"."nickname",
       "blog_user"."email",
       "blog_user"."first_name",
       "blog_user"."last_name"
  FROM "blog_post"
 INNER JOIN "blog_user"
    ON ("blog_post"."creator_id" = "blog_user"."id")

Execution time: 0.001355s [Database: default]
None
ivan_petrov

In [30]: Post.objects.create(title="Intro", body="Hi, my name is Bob!", creator=User.objects.create(
    ...: email="bob@blogs.org",
    ...: first_name="Bob",
    ...: last_name="Smith",
    ...: ),
    ...: )
INSERT INTO "blog_user" ("created_at", "updated_at", "nickname", "email", "first_name", "last_name")
VALUES ('2025-09-12 13:38:12.607700', '2025-09-12 13:38:12.607855', NULL, 'bob@blogs.org', 'Bob', 'Smith') RETURNING "blog_user"."id"

Execution time: 0.007025s [Database: default]
INSERT INTO "blog_post" ("created_at", "updated_at", "title", "body", "creator_id")
VALUES ('2025-09-12 13:38:12.658133', '2025-09-12 13:38:12.658247', 'Intro', 'Hi, my name is Bob!', 6) RETURNING "blog_post"."id"

Execution time: 0.004837s [Database: default]
Out[30]: <Post: Post object (3)>

In [33]: post2 = Post.objects.create(
    ...: title="Update",
    ...: body="i'm tried...",
    ...: creator_id=5,
    ...: )
INSERT INTO "blog_post" ("created_at", "updated_at", "title", "body", "creator_id")
VALUES ('2025-09-12 13:42:44.081289', '2025-09-12 13:42:44.081386', 'Update', 'i''m tried...', 5) RETURNING "blog_post"."id"   

Execution time: 0.005104s [Database: default]

In [45]: post = Post.objects.get(id=3)
SELECT "blog_post"."id",
       "blog_post"."created_at",
       "blog_post"."updated_at",
       "blog_post"."title",
       "blog_post"."body",
       "blog_post"."creator_id"
  FROM "blog_post"
 WHERE "blog_post"."id" = 3
 LIMIT 21

Execution time: 0.001008s [Database: default]

In [46]: print(post.creator.email)
SELECT "blog_user"."id",
       "blog_user"."created_at",
       "blog_user"."updated_at",
       "blog_user"."nickname",
       "blog_user"."email",
       "blog_user"."first_name",
       "blog_user"."last_name"
  FROM "blog_user"
 WHERE "blog_user"."id" = 6
 LIMIT 21

Execution time: 0.001253s [Database: default]
bob@blogs.org


In [57]: bob = User.objects.get(first_name="Bob")
SELECT "blog_user"."id",
       "blog_user"."created_at",
       "blog_user"."updated_at",
       "blog_user"."nickname",
       "blog_user"."email",
       "blog_user"."first_name",
       "blog_user"."last_name"
  FROM "blog_user"
 WHERE "blog_user"."first_name" = 'Bob'
 LIMIT 21

Execution time: 0.001336s [Database: default]

In [58]: for post in bob.post_set.all():
    ...:     print(post.id, post.title)
    ...: 
SELECT "blog_post"."id",
       "blog_post"."created_at",
       "blog_post"."updated_at",
       "blog_post"."title",
       "blog_post"."body",
       "blog_post"."creator_id"
  FROM "blog_post"
 WHERE "blog_post"."creator_id" = 6

Execution time: 0.000935s [Database: default]
3 Intro

some_user.post_set.delete()

OneToOneField - связь один к одному 

модель Person
parent = models.ForeignKey('self', ...) 
                           'app_name.ModelName'

ManyToManyField
In [60]: intro = Tag.objects.create(title="intro")
INSERT INTO "blog_tag" ("created_at", "updated_at", "title")
VALUES ('2025-09-12 14:51:19.909468', '2025-09-12 14:51:19.911668', 'intro') RETURNING "blog_tag"."id"

Execution time: 0.011234s [Database: default]

In [61]: Post.objects.get(title="Intro").tags.add(intro)
SELECT "blog_post"."id",
       "blog_post"."created_at",
       "blog_post"."updated_at",
       "blog_post"."title",
       "blog_post"."body",
       "blog_post"."creator_id"
  FROM "blog_post"
 WHERE "blog_post"."title" = 'Intro'
 LIMIT 21

Execution time: 0.001366s [Database: default]
BEGIN

Execution time: 0.000709s [Database: default]
INSERT
    OR
IGNORE INTO "blog_post_tags" ("post_id", "tag_id")
VALUES (3, 1)

Execution time: 0.008948s [Database: default]

In [62]:
ManyRelatedManager 

post = Post.objects.get(title="Intro")
post.tags.remove(intro)

In [63]: Post.objects.filter(tags__title="intro")
Out[63]: SELECT "blog_post"."id",
       "blog_post"."created_at",
       "blog_post"."updated_at",
       "blog_post"."title",
       "blog_post"."body",
       "blog_post"."creator_id"
  FROM "blog_post"
 INNER JOIN "blog_post_tags"
    ON ("blog_post"."id" = "blog_post_tags"."post_id")
 INNER JOIN "blog_tag"
    ON ("blog_post_tags"."tag_id" = "blog_tag"."id")
 WHERE "blog_tag"."title" = 'intro'
 LIMIT 21

Execution time: 0.002930s [Database: default]
<QuerySet [<Post: Post object (3)>]>

In [65]: intro = Tag.objects.get(title="intro")
SELECT "blog_tag"."id",
       "blog_tag"."created_at",
       "blog_tag"."updated_at",
       "blog_tag"."title"
  FROM "blog_tag"
 WHERE "blog_tag"."title" = 'intro'
 LIMIT 21

Execution time: 0.001142s [Database: default]

In [66]: for post in intro.post_set.all():
    ...:     print(post.title)
    ...: 
SELECT "blog_post"."id",
       "blog_post"."created_at",
       "blog_post"."updated_at",
       "blog_post"."title",
       "blog_post"."body",
       "blog_post"."creator_id"
  FROM "blog_post"
 INNER JOIN "blog_post_tags"
    ON ("blog_post"."id" = "blog_post_tags"."post_id")
 WHERE "blog_post_tags"."tag_id" = 1

Execution time: 0.001215s [Database: default]
Intro

In [67]: 

add
remove
clear

through 

class Book(models.Model):
    price = models.DecimalField(max_digits=10, decimal_places=2)
    ...

total_price = sum(book.price for book in Book.objects.all())

.aggregate()

from django.db.models import Avg, Max, Min, Sum, Count

Book.objects.aggregate(Avg('price'))
{'price__avg': 10.0}

Book.objects.aggregate(average_price=Avg('price'))
{'average_price': 10.0}

Book.objects.aggregate(Avg('price'), Max('price'), Min('price'), Sum('price'), Count('price'))
{'price__avg': 10.0, 'price__max': 100.0, 'price__min': 1.0, 'price__sum': 100.0, 'price__count': 10}


In [5]: author = User.objects.get(id=5)
SELECT "blog_user"."id",
       "blog_user"."created_at",
       "blog_user"."updated_at",
       "blog_user"."nickname",
       "blog_user"."email",
       "blog_user"."first_name",
       "blog_user"."last_name"
  FROM "blog_user"
 WHERE "blog_user"."id" = 5
 LIMIT 21

Execution time: 0.001027s [Database: default]

In [6]: posts = [(p, p.postcomment_set.count()) for p in author.post_set.all()]
SELECT "blog_post"."id",
       "blog_post"."created_at",
       "blog_post"."updated_at",
       "blog_post"."title",
       "blog_post"."body",
       "blog_post"."creator_id"
  FROM "blog_post"
 WHERE "blog_post"."creator_id" = 5

Execution time: 0.007711s [Database: default]
SELECT COUNT(*) AS "__count"
  FROM "blog_postcomment"
 WHERE "blog_postcomment"."post_id" = 2

Execution time: 0.002384s [Database: default]
SELECT COUNT(*) AS "__count"
  FROM "blog_postcomment"
 WHERE "blog_postcomment"."post_id" = 4

Execution time: 0.000979s [Database: default]

In [7]: posts
Out[7]: [(<Post: Post object (2)>, 0), (<Post: Post object (4)>, 0)]

In [8]: 

.annotate()

from django.db.models import Avg, Max, Min, Sum, Count

posts = author.post_set.annotate(comment_count=Count('postcomment'))


In [8]: posts = author.post_set.annotate(comment_count=Count('postcomment'))

In [9]: for post in posts:
   ...:     print(post.title, post.comment_count)
   ...: 
SELECT "blog_post"."id",
       "blog_post"."created_at",
       "blog_post"."updated_at",
       "blog_post"."title",
       "blog_post"."body",
       "blog_post"."creator_id",
       COUNT("blog_postcomment"."id") AS "comment_count"
  FROM "blog_post"
  LEFT OUTER JOIN "blog_postcomment"
    ON ("blog_post"."id" = "blog_postcomment"."post_id")
 WHERE "blog_post"."creator_id" = 5
 GROUP BY "blog_post"."id",
          "blog_post"."created_at",
          "blog_post"."updated_at",
          "blog_post"."title",
          "blog_post"."body",
          "blog_post"."creator_id"

Execution time: 0.001246s [Database: default]
Первый пост 0
Update 0

In [10]: users = User.objects.annotate(post_count=Count('post'))

In [11]: users = users.order_by("-post_count")

In [14]: posts = Post.objects.annotate(Count("tags"))

In [15]: print(posts[0].tags__count)
SELECT "blog_post"."id",
       "blog_post"."created_at",
       "blog_post"."updated_at",
       "blog_post"."title",
       "blog_post"."body",
       "blog_post"."creator_id",
       COUNT("blog_post_tags"."tag_id") AS "tags__count"
  FROM "blog_post"
  LEFT OUTER JOIN "blog_post_tags"
    ON ("blog_post"."id" = "blog_post_tags"."post_id")
 GROUP BY "blog_post"."id",
          "blog_post"."created_at",
          "blog_post"."updated_at",
          "blog_post"."title",
          "blog_post"."body",
          "blog_post"."creator_id"
 LIMIT 1

Execution time: 0.001251s [Database: default]
0

In [16]: for post in posts:
    ...:     print(post.tags__count)
    ...: 
SELECT "blog_post"."id",
       "blog_post"."created_at",
       "blog_post"."updated_at",
       "blog_post"."title",
       "blog_post"."body",
       "blog_post"."creator_id",
       COUNT("blog_post_tags"."tag_id") AS "tags__count"
  FROM "blog_post"
  LEFT OUTER JOIN "blog_post_tags"
    ON ("blog_post"."id" = "blog_post_tags"."post_id")
 GROUP BY "blog_post"."id",
          "blog_post"."created_at",
          "blog_post"."updated_at",
          "blog_post"."title",
          "blog_post"."body",
          "blog_post"."creator_id"

Execution time: 0.001309s [Database: default]
0
0
0
1

In [17]: 

In [17]: posts = Post.objects.annotate(total_tags=Count("tags"))

In [18]: print(posts[3].total_tags)
SELECT "blog_post"."id",
       "blog_post"."created_at",
       "blog_post"."updated_at",
       "blog_post"."title",
       "blog_post"."body",
       "blog_post"."creator_id",
       COUNT("blog_post_tags"."tag_id") AS "total_tags"
  FROM "blog_post"
  LEFT OUTER JOIN "blog_post_tags"
    ON ("blog_post"."id" = "blog_post_tags"."post_id")
 GROUP BY "blog_post"."id",
          "blog_post"."created_at",
          "blog_post"."updated_at",
          "blog_post"."title",
          "blog_post"."body",
          "blog_post"."creator_id"
 LIMIT 1
OFFSET 3

Execution time: 0.001116s [Database: default]
1

In [19]: 

в случае связи M:M .annotate(Sum("views"))
post = Post.objects.create(
    title="django orm",
    body="i'm tried...",
    views=100,
)

post.tags.add(tag1, tag2, tag3)

wrong_query = Post.objects.annotate(total_views=Sum("views")).get(id=post.id)
print(wrong_query.total_views)

correct_query = Post.objects.annotate(
    total_views=Sum("views", distinct=True)
).get(id=post.id)

print(correct_query.total_views)

posts = Post.objects.annotate(comment_count=Count("postcomment"))
for post in posts:
    print(post.title, post.comment_count)

authors = User.objects.annotate(post_count=Count("post"))
for author in authors:
    print(author.nickname, author.post_count)

posts = Post.objects.annotate(avg_lenght=Avg("postcomment__body__length"))

В учебном проекте создайте несколько постов и тегов
Пометьте разные посты разным количеством тегов
Постройте запрос, который будет возвращать "Top 3" тега по количеству помеченных ими постов.